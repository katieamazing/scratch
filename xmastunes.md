to the tune of "O Christmas Tree"

Binary Tree, Binary Tree
Your nodes are bright and sparkly
I traverse you recursively
Binary Tree, Binary Tree

hip hip array

to the tune of "Silent Night"

Linked list, linked list
Pointers to the next node
O(1) to add a new node
O(n) to access a node
Terrible for random access
Linked linked list

to "we three kings"

Three techniques for algo design
They can make your programs shine
Greedy, Dynamic, Divide and Conquer
They'll help with your deadline

O greedy algo, locally best
Dynamic, memoize don't retest
Divide and conquer, break into subproblems
Recursively solve and take a rest

to "o come all ye faithful"

When it comes to sorting
You have lots of options
Bubble sort is the first sort you might learn
It has a cute name
Sorts by exchanging
But it is best case n
and average n squared
Linear memory But
It's not fast

Then you have merge sort
n log n all the time
But it takes n memory though it's parallizeable
Consider heap sort
Also n log n
sorts by selection
in linear memory
but it's unstable

Quicksort comes up often
Uses partitioning
n log n time and a stack for log n space
Exotic sort types
Often hide beneath the hood
Python uses Timsort
So does Java
Lua uses Shell sort
JS and Ruby stick to quicksort
